Preliminaries:\\

Description of main results.

    Notational preliminaries
    Actual results
        break down into sections as need
        Use theorem and lemma environments appropriately. 


\subsection*{Notatioal preliminaries}\\


Let $S = {s_1 \ldot, s_m}$ be a set of m strings over the alphabet $\sum$. The paper uses $OPT(S)$ which denotes the length of the shortest common superstring for the set $S$. If given two strings $s$ and $t$ the term $ov(s,t)$ denotes the amount of overlap between $s$ and $t$. For example, if $s = uv$ and $t = vw$ then $ov(s,t) = |v|$. The paper uses the term $pref(s,t)$ to denote the prefix of $s$ with respsect to $t$, that is $pref(s,t) = u$. Lastly, $d(s,t)$ denotes the distance from $s$ to $t$. That is, $d(s,t) = |u|$. Finally, let $SCS$ denote the shortest common superstring for some algorithm. For a set of strings $S = {s_1, ..., s_m}$ where each string is unique, and any $s_i \in S$ is a substring of any other $s_k in S$ then the $SCS$ is trivially the concatenation of strings $SCS = s_1s_2...s_m$. There are these notions $first(SCS)$ and $last(SCS)$ which denote the first string in $SCS$ is the first string in the set $S$, and $last(SCS)$ is the last string in $SCS$. That is $first(SCS) = s_1$ and $last(SCS) = s_m$. \\

Throughout the analysis we talk about constructing graphs, unless otherwise specified we are constructing a overlap graph, or a distance graph:\\

\textbf{Distance graph}
The graph $G = (V,E,c)$ is an edge-weighted, complete directed graph. \\
The set of verticies $V$ comes from the strings from $S$. That is each vertex in $V$ is one of the strings $s_1, ..., s_m \in S$.\\
The costs $c$ between edges is denoted $c(v_i,v_j)$ where the cost is really just the prefix between strings in $S$, that is $c(v_i,v_j) = pref(s_i,s_j)$. In English the weights of edges is the distance between strings $s_i$ and $s_j$.\\
Lastly, $E=V^2$.\\

\begin{figure}[h]
 \centering
   \includegraphics[width=.4\textwidth]{distance.png}
\end{figure}





\textbf{Overlap graph}
The graph $G = (V,E,c)$ is an edge-weighted, complete directed graph. \\
Like above, $V \in S$ and $E=V^2$.\\
The cost $c$ between edges is denoted like above, but the true cost is $c(v_i,v_j) = ov(s_i,s_j)$. In English, the weights of the edges is the overlaps between strings $s_i$ and $s_j$\\

\begin{figure}[h]
 \centering
   \includegraphics[width=.4\textwidth]{overlap.png}
\end{figure}



\subsection*{Results of the paper}\\

The papers that set up greedy before this paper conjectured that GREEDY could be $ |GREEDY_{SCS}| \leq |2OPT(S)|$. We will describe how the authors proved that the upperbound string for a slightly modified GREEDY is actually $ |GREEDY_{SCS}| \leq |4OPT|(S)$.\\\\


\textbf{$4 \ldot OPT(S)$ upper bound for GREEDY}\\

When we take the SCS problem and reduce it, we end up with a set of strings $S$ which can be represented as a weighted graph $G$. This opens up a slew of graph algorithms that previously wouldn't have worked without the reduction. The algorithm works by finding a vertex disjoint cycle cover, where each vertex in the graph is contained in at least one cycle. In order to get a vertex disjoint cycle cover, the authors use a polynomial-time algorithm for the assignment problem. The assignment problem is the problem of finding a maximal or minimal weight macthing between verticies in a weighted bipartite graph. To prove that the algorithm finds a SCS of length at most $4 \ldot OPT(S)$ they prove that the the assignment algorithm finds some optimial weight matching on graph $G$, and when the cycles in $G$ are found and unraveled they are at most length 4 of the optimal solution.

To prove GREEDY's approximation they first prove that an algorithm ``Concat-cycles'' produces a string at most 4 of the optimal, then show that GREEDY mimics concat-cycles.\\

\textbf{Concat-cycle algorithm}\\

\textbf{A.} Given a set of strings $S$ reduce the set of strings to a distance graph $G$. \\
\textbf{B.} Run a minimum weight assignment on $G$. The resulting set of cycles is $C$ where $C = {c_1, c_n}$\\
\textbf{C.} Take the cycles from $C$ and ``unravel'' them into strings $s_i'$. $s_i'$ can be defined as the verticies $v_1 ... v_r ... v_1$. In English this is the string that is created by travelling through the verticies in a cycle until we've visited ever vertex in that cycle.\\
\textbf{D.} for each string $s_i, s_{i+1}, ...$ concatenate them which gives us a string $SCS$.\\

\textbf{Theorem}\\
The algorithm concat cycles produces a string of length at most $4\ldot OPT(S)$\\\\




